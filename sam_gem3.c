// ------------------------------------------------------------------
//   sam_gem3.c
//   Copyright (C) 2022-2022 Genozip Limited
//   Please see terms and conditions in the file LICENSE.txt

// Compresses auxilliary fields generated by gem3 mapper

#include "genozip.h"
#include "sam_private.h"
#include "strings.h"
#include "reference.h"
#include "segconf.h"
#include "seg.h"
#include "piz.h"
#include "reconstruct.h"

// ----------------------------------------------------------------------------------------------
// XB:A gem3: Bisulfite conversion: C if its a C->T and G if its G->A: 
// http://dcc.blueprint-epigenome.eu/#/md/bs_seq_grch38
// ----------------------------------------------------------------------------------------------

static inline char XB_prediction (VBlockSAMP vb) 
{ 
    return (vb->c2t_minus_g2a >= 0) ? 'C' : 'G'; 
}

// 2 possible values: G C
void sam_seg_gem3_XB_A (VBlockSAMP vb, ZipDataLineSAM *dl, STRp(xb), unsigned add_bytes)
{
    segconf_set_has (OPTION_XB_A);

    if (xb_len == 1 && *xb == XB_prediction (vb))
        seg_by_did (VB, (char[]){ SNIP_SPECIAL, SAM_SPECIAL_GEM3_XB }, 2, OPTION_XB_A, add_bytes);

    else 
        // note: prediction sometimes fails when both c2t and g2a are near-0, eg "c2t=1 g2a=2" or "c2t=0 g2a=2"
        seg_by_did (VB, STRa(xb), OPTION_XB_A, add_bytes);
}

SPECIAL_RECONSTRUCTOR (sam_piz_special_GEM3_XB)
{
    if (reconstruct) 
        RECONSTRUCT1 (XB_prediction (VB_SAM));

    return NO_NEW_VALUE;
}

// ------------------------------------------------------------------------
// XA:Z "Alternative alignments" (a BWA, gem3 feature)
// In gem3, when used with --bisulfite XA includes the XB of each alignment
// Example: XA:Z:chr1,+G10006,103M1I36M1D11M,9;
//                     ^
// ------------------------------------------------------------------------

// split the pos strand-XB-pos string (generated with --bisulfite), eg "-C10000" to strand "-" XB "C" and pos "10000"
bool seg_seg_gem3_XA_strand_XB_pos_cb (VBlockP vb, ContextP ctx, STRp(field), uint32_t rep)
{
    char strand = field[0];
    char xb     = field[1];

    if (field_len < 3 || (strand != '+' && strand != '-') || (xb != 'C' && xb != 'G'))  
        return false; // invalid XA format - expecting pos to begin with the strand and XB

    if (segconf.is_sorted && !segconf.running) {
        sam_seg_BWA_XA_pos (vb, &field[2], field_len-2, rep);
        sam_seg_BWA_XA_strand (vb, 2 + ((strand=='+') | (xb=='G') << 1), 2); // word_indices set in sam_seg_BWA_XA_initialize
    }
    
    // case: for a collated (or otherwise unsorted) file, we just seg normally (also: in segconf.running)
    else {
        seg_by_did (VB, field, 2, OPTION_XA_STRAND, 2);
        seg_integer_or_not (vb, CTX(OPTION_XA_POS), &field[2], field_len-2, field_len-2);
    }
    seg_by_ctx (VB, xa_strand_pos_snip, xa_strand_pos_snip_len, ctx, 0); // pre-created constant container

    return true; // segged successfully
}


