// ------------------------------------------------------------------
//   vcf_private.h
//   Copyright (C) 2020-2024 Genozip Limited. Patent Pending.
//   Please see terms and conditions in the file LICENSE.txt
//
//   WARNING: Genozip is proprietary, not open source software. Modifying the source code is strictly prohibited
//   and subject to penalties specified in the license.

#pragma once

#include "vblock.h"
#include "vcf.h"
#include "website.h"
#include "seg.h"

#define VCF_FIELD_NAMES "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO"
#define VCF_FIELD_NAMES_LONG VCF_FIELD_NAMES "\tFORMAT"

typedef struct {
    WordIndex chrom;             // Seg: enter as node_index ; Merge: convert to word_index
    PosType32 pos;               // 
    PosType32 end_delta;         // Delta of INFO/END vs POS (same in both coordinates) - used in case chrom and pos are the same
    uint32_t tie_breaker;        // tie-breaker in case chrom, pos and end are the same
    
    bool has_haplotype_data : 1; // FORMAT field contains GT
    bool has_genotype_data  : 1; // FORMAT field contains subfields other than GT

    WordIndex format_node_i;     // the node_index into contexts[VCF_FORMAT].nodes and also format_mapper_buf that applies to this line. Data on the fields is in vb->format_mapper_buf[dl.format_node_i]
} ZipDataLineVCF;
#define DATA_LINE(i) B(ZipDataLineVCF, vb->lines, i)

typedef enum { VCF_v_UNKNOWN, VCF_v4_1, VCF_v4_2, VCF_v4_3, VCF_v4_4, VCF_v4_5 } VcfVersion;

#define ZIP_MAX_PLOIDY_FOR_MUX 4 // ZIP only. In PIZ use z_file->max_ploidy_for_mux
#define ZIP_NUM_DOSAGES_FOR_MUX (ZIP_MAX_PLOIDY_FOR_MUX+1) // ZIP only: 0 to ZIP_MAX_PLOIDY_FOR_MUX
typedef MULTIPLEXER(ZIP_NUM_DOSAGES_FOR_MUX) DosageMultiplexer, *DosageMultiplexerP;

#define VCF_MAX_ARRAY_ITEMS SMALL_CON_NITEMS

typedef packed_enum { 
    VT_UNKNOWN, 
    VT_SNP,         // A G 
    VT_DEL,         // AGG A   - must be left anchored
    VT_INS,         // A AGG   - must be left anchored
    VT_SNP_LONG,    // AGG CGG 
    VT_DEL_LONG,    // AGG AG
    VT_INS_LONG,    // AG AGG 
    VT_SUBST_DEL,   // ATATGTG ATG - left anchored, part of remaining bases after deletion are substituted 
    VT_SUBST_INS,   // ATG ATATGTG - left anchored, part of ref is substituted, and then insertion 
    VT_MISSING      // A *
} VariantType;

typedef struct VBlockVCF {
    VBLOCK_COMMON_FIELDS

    // charactaristics of the data
    Ploidy ploidy;           // ZIP only
    VcfVersion vcf_version;
    uint64_t first_line;     // ZIP: used for --add_line_numbers  
    
    rom main_ref;            // Seg: pointer into txt_data of REF in main field, set by vcf_seg_txt_line
    rom main_alt;

    // ZIP/PIZ details alts -  
    int8_t n_alts; // generated by vcf_parse_main_alt: 0 means not parsed yet, -1 means parse fails (eg bc too many alts)
    rom alts[MAX_ALLELES-1];
    uint32_t alt_lens[MAX_ALLELES-1];
    VariantType var_types[MAX_ALLELES-1]; // of main ALT[] fields

    unsigned main_ref_len, main_alt_len;
        
    // FORMAT/AD
    int64_t ad_values[VCF_MAX_ARRAY_ITEMS];
    
    // FORMAT stuff 
    Buffer format_mapper_buf;       // ZIP only: an array of type Container - one entry per entry in CTX(VCF_FORMAT)->nodes   
    Buffer format_contexts;         // ZIP only: an array of format_mapper_buf.len of ContextBlock
    Buffer last_format;             // ZIP only: cache previous line's FORMAT string

    #define first_idx idx_AN        // ZIP: INFO fields indices within INFO
    // IMPORTANT: when adding, add to X() in vcf_seg_info_subfields
    int16_t idx_AN, idx_AC, idx_AF, idx_MLEAC, idx_MLEAF, idx_AC_Hom, idx_AC_Het, idx_AC_Hemi, idx_QD, idx_DP, idx_SF, idx_AS_SB_TABLE;
    #define has(f)   (vb->idx_##f  != -1)
    #define after_idx mux_PLn

    // Multiplexers
    #define first_mux mux_PLn
    DosageMultiplexer mux_PLn, mux_GL, mux_GP, mux_PRI, mux_DS, mux_PP, mux_PVAL, mux_FREQ, mux_RD, 
                      mux_VAF, mux_AD[2], mux_ADALL[2];

    thool PL_mux_by_DP;
    
    #define MAX_DP_FOR_MUX 51       // TODO: 60 would be better as it was up to 15.0.35, but mux is currently limited to 256 channels
    MULTIPLEXER(MAX_DP_FOR_MUX * ZIP_NUM_DOSAGES_FOR_MUX) mux_PLy;
    MULTIPLEXER(7 * ZIP_NUM_DOSAGES_FOR_MUX) mux_GQ;
    MULTIPLEXER(MAX_DP_FOR_MUX) mux_RGQ;   

    Multiplexer2 mux_POS;           // GVCF: multiplex by whether this field is END or POS
    Multiplexer2 mux_QUAL, mux_INFO;// GVCF: multiplex by has_RGQ
    Multiplexer2 mux_FORMAT_DP;     // channel=1 by AD or SDP, channel=0 transposed if AD/SDP not available           
    Multiplexer2 mux_IGT, mux_IPS;  // multiplex by (sample_i>0)
    Multiplexer3 mux_VC;            // multiplex dbSNP's INFO/VC by VARTYPE
    Multiplexer3 mux_GQX;           // multiplex Isaac's FORMAT/GQX
    Multiplexer3 mux_BAF, mux_X, mux_Y; // Illumina genotyping: by adjusted dosage 

    #define after_mux is_del_sv

    // DVCF stuff
    bool is_del_sv;                 // is ALT == "<DEL>"
    bool is_unsorted;               // ZIP: line order of this VB is unsorted 
} VBlockVCF;

typedef VBlockVCF *VBlockVCFP;
#define VB_VCF ((VBlockVCFP)vb)

typedef ContextP ContextPBlock[MAX_FIELDS];

// VCF standard keys
#define HK_GENOZIP_CMD   "##genozip_command="
#define TAG_SOURCE       Source=\""GENOZIP_URL"\""
#define KH_INFO          "##INFO=<ID="
#define HK_CONTIG        "##contig="

extern uint32_t vcf_num_samples; // ZIP
extern char *vcf_samples_is_included;
#define samples_am_i_included(sample_i) (!flag.samples || ((bool)(vcf_samples_is_included[sample_i]))) // macro for speed - this is called in the critical loop of reconstructing samples
extern VcfVersion vcf_header_get_version (void);

#define BII(x) B(InfoItem, CTX(VCF_INFO)->info_items, vb->idx_##x)

// POS stuff
extern void vcf_seg_pos (VBlockVCFP vb, ZipDataLineVCF *dl, STRp(pos_str));
extern void vcf_seg_INFO_END (VBlockVCFP vb, ContextP end_ctx, STRp(end_str));

// AC / AF / AN
extern void vcf_seg_INFO_AC (VBlockVCFP vb, ContextP ac_ctx, STRp(ac_str));
extern void vcf_seg_INFO_AN (VBlockVCFP vb);
extern void vcf_seg_INFO_MLEAC (VBlockVCFP vb, ContextP ac_ctx, STRp(ac_str));
extern void vcf_seg_INFO_MLEAF (VBlockVCFP vb, ContextP ctx, STRp(mleaf));
extern void vcf_piz_insert_INFO_AN (VBlockVCFP vb);

// Samples stuff
extern void vcf_seg_FORMAT (VBlockVCFP vb, ZipDataLineVCF *dl, STRp(fmt));
extern void vcf_samples_zip_initialize (void);
extern void vcf_samples_seg_initialize (VBlockVCFP vb);
extern void vcf_samples_seg_finalize (VBlockVCFP vb);

extern rom vcf_seg_samples (VBlockVCFP vb, ZipDataLineVCF *dl, int32_t *len, char *next_field, bool *has_13);
extern int vcf_seg_get_mux_channel_i (VBlockVCFP vb);
extern int vcf_piz_get_mux_channel_i (VBlockP vb);
extern ContextP vcf_seg_FORMAT_mux_by_dosage (VBlockVCFP vb, ContextP ctx, STRp(cell), const DosageMultiplexer *mux);
extern void vcf_seg_FORMAT_mux_by_dosagexDP (VBlockVCFP vb, ContextP ctx, STRp(cell), void *mux_p);

eSTRl(snip_copy_af);

// FORMAT/GT stuff
extern WordIndex vcf_seg_FORMAT_GT (VBlockVCFP vb, ContextP ctx, ZipDataLineVCF *dl, STRp(cell), bool has_ps, bool has_null_dp);
extern void vcf_seg_FORMAT_GT_complete_missing_lines (VBlockVCFP vb);
extern void vcf_piz_FORMAT_GT_rewrite_predicted_phase (VBlockP vb, char *recon, uint32_t recon_len);
extern void vcf_piz_GT_cb_null_GT_if_null_DP (VBlockP vb , char *recon);
extern int vcf_piz_GT_get_last_dosage (VBlockP vb);

// GIAB trio stuff
extern void vcf_giab_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_FORMAT_IGT (VBlockVCFP vb, ContextP ctx, STRp(igt));
extern void vcf_seg_FORMAT_IPS (VBlockVCFP vb, ZipDataLineVCF *dl, ContextP ctx, STRp(ips));
extern void vcf_seg_ADALL_items (VBlockVCFP vb, ContextP ctx, STRps(item), ContextP *item_ctxs, const int64_t *values);

#define IS_TRIVAL_FORMAT_SUBFIELD ((!recon_len || (recon_len==1 && *recon=='.')) && dict_id_is_vcf_format_sf (ctx->dict_id))
extern void vcf_FORMAT_PL_decide (VBlockVCFP vb);
extern void vcf_FORMAT_PL_after_vbs (void);

// FORMAT/PS and FORMAT/PID stuff
extern void vcf_samples_zip_initialize_PS_PID (void);
extern void vcf_samples_seg_initialize_LOOKBACK (VBlockVCFP vb);
extern void vcf_samples_seg_finalize_PS_PID (VBlockVCFP vb);
extern void vcf_seg_FORMAT_PS_PID (VBlockVCFP vb, ZipDataLineVCF *dl, ContextP ctx, STRp(value));
extern void vcf_seg_FORMAT_PS_PID_missing_value (VBlockVCFP vb, ContextP ctx, rom end_of_sample);
extern void vcf_samples_seg_initialize_PS_PID (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_piz_ps_pid_lookback_insert (VBlockP vb, Did did_i, STRp(recon)); 
extern void vcf_piz_ps_pid_lookback_shift (VBlockP vb, STRp(insert));

// FORMAT/GQ
extern void vcf_segconf_finalize_GQ (VBlockVCFP vb);
extern void vcf_seg_FORMAT_GQ (VBlockVCFP vb);

// -------------
// GATK stuff
// -------------
extern void vcf_gatk_zip_initialize (void);
extern void vcf_gatk_seg_initialize (VBlockVCFP vb);

// INFO/SF
extern bool vcf_seg_INFO_SF_init (VBlockVCFP vb, ContextP sf_ctx, STRp(value));
extern void vcf_seg_INFO_SF_one_sample (VBlockVCFP vb);
extern void vcf_piz_GT_cb_calc_INFO_SF (VBlockVCFP vcf_vb, unsigned rep, char *recon, int32_t recon_len);
extern void vcf_piz_insert_INFO_SF (VBlockVCFP vcf_vb);

// INFO/QD stuff
typedef packed_enum { QD_PRED_NONE, QD_PRED_INFO_DP, QD_PRED_INFO_DP_P001, QD_PRED_INFO_DP_M001, 
                      QD_PRED_SUM_DP,  QD_PRED_SUM_DP_P001,  QD_PRED_SUM_DP_M001, NUM_QD_PRED_TYPES } QdPredType;
extern void vcf_seg_sum_DP_for_QD (VBlockVCFP vb, int64_t value);
extern void vcf_seg_INFO_QD (VBlockP vb);
extern void vcf_piz_sum_DP_for_QD (VBlockP vb, STRp(recon));
extern void vcf_piz_insert_INFO_QD (VBlockVCFP vb);

extern void vcf_seg_INFO_RAW_MQandDP (VBlockVCFP vb, ContextP ctx, STRp(value));
extern bool vcf_seg_INFO_BaseCounts (VBlockVCFP vb, ContextP ctx_basecounts, STRp(value)); // returns true if caller still needs to seg 
extern void vcf_seg_INFO_AS_SB_TABLE (VBlockP vb);
extern void vcf_piz_sum_SB_for_AS_SB_TABLE (VBlockP vb, STRp(recon));
extern void vcf_piz_insert_INFO_AS_SB_TABLE (VBlockVCFP vb);
extern void vcf_seg_INFO_RU (VBlockVCFP vb, ContextP ctx, STRp(ru));
extern void vcf_seg_INFO_RPA (VBlockVCFP vb, ContextP ctx, STRp(rpa_str));

// INFO stuff

typedef struct { char name[MAX_TAG_LEN]; // not nul-terminated, including '=' if there is one
                 rom value; 
                 unsigned name_len, value_len; 
                 ContextP ctx; } InfoItem;

extern void vcf_info_zip_initialize (void);
extern void vcf_info_seg_initialize (VBlockVCFP vb);
extern void vcf_piz_insert_INFO_DP (VBlockVCFP vb);

extern void vcf_seg_info_subfields (VBlockVCFP vb, STRp(info));
extern void vcf_seg_finalize_INFO_fields (VBlockVCFP vb);
extern bool vcf_seg_INFO_allele (VBlockP vb_, ContextP ctx, STRp(value), uint32_t repeat);

// Refalt stuff
extern void vcf_refalt_seg_main_ref_alt (VBlockVCFP vb, STRp(ref), STRp(alt));
typedef enum { EQUALS_NEITHER, EQUALS_REF, EQUALS_ALT, EQUALS_MISSING } RefAltEquals;
extern bool vcf_refalt_piz_is_variant_snp (VBlockVCFP vb);
extern bool vcf_refalt_piz_is_variant_indel (VBlockVCFP vb);
extern void vcf_piz_refalt_parse (VBlockVCFP vb);
extern void vcf_parse_main_alt (VBlockVCFP vb);

// GVCF stuff
extern bool vcf_piz_line_has_RGQ (VBlockVCFP vb);

// Illumina genotyping stuff
extern void vcf_illum_gtyping_zip_initialize (void);
extern void vcf_illum_gtyping_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_PROBE_A (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_seg_PROBE_B (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_seg_ILLUMINA_CHR (VBlockVCFP vb, ContextP ctx, STRp(chr));
extern void vcf_seg_ILLUMINA_POS (VBlockVCFP vb, ContextP ctx, STRp(pos));
extern void vcf_seg_ILLUMINA_STRAND (VBlockVCFP vb, ContextP ctx, STRp(strand));
extern void vcf_seg_ALLELE_A (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_seg_ALLELE_B (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_seg_mux_by_adjusted_dosage (VBlockVCFP vb, ContextP ctx, STRp(baf), const Multiplexer3 *mux);

// dbSNP
extern void vcf_dbsnp_zip_initialize (void);
extern void vcf_dbsnp_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_INFO_RS (VBlockVCFP vb, ContextP ctx, STRp(rs));
extern void vcf_seg_INFO_RSPOS (VBlockVCFP vb, ContextP ctx, STRp(rspos));
extern void vcf_seg_INFO_VC (VBlockVCFP vb, ContextP ctx, STRp(vc));

// GWAS-VCF stuff
extern void vcf_gwas_zip_initialize (void);
extern void vcf_gwas_seg_initialize (VBlockVCFP vb);
extern void vcf_gwas_seg_FORMAT_ID (VBlockVCFP vb, ContextP ctx, STRp(id));

// VAGrENT stuff
extern void vcf_vagrent_zip_initialize (void);
extern void vcf_seg_INFO_VD (VBlockVCFP vb, ContextP ctx, STRp(vd));
extern void vcf_seg_INFO_VW (VBlockVCFP vb, ContextP ctx, STRp(vw));

// VEP stuff
extern uint64_t _INFO_Allele;
extern void vcf_vep_zip_initialize (void);
extern void vcf_vep_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_INFO_CSQ (VBlockVCFP vb, ContextP ctx, STRp(value));

// SnpEff stuff
extern void vcf_seg_INFO_ANN (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_seg_INFO_EFF (VBlockVCFP vb, ContextP ctx, STRp(value));

// COSMIC stuff
extern void vcf_cosmic_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_INFO_LEGACY_ID (VBlockVCFP vb, ContextP ctx, STRp(lid));
extern void vcf_seg_INFO_SO_TERM (VBlockVCFP vb, ContextP ctx, STRp(st));

// ClinVar stuff
extern void vcf_seg_hgvs_consolidate_stats (VBlockVCFP vb, Did parent);
extern bool vcf_seg_INFO_HGVS (VBlockP vb_, ContextP ctx, STRp(value), uint32_t repeat);

// Mastermind stuff
extern void vcf_mastermind_zip_initialize (void);
extern void vcf_mastermind_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_mastermind_HGVSG (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_seg_INFO_MMID3 (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_seg_INFO_MMURI3 (VBlockVCFP vb, ContextP ctx, STRp(value));

// ICGC stuff
extern void vcf_seg_INFO_mutation (VBlockVCFP vb, ContextP ctx, STRp(mut));

// ISAAC stuff
extern void vcf_isaac_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_FORMAT_GQX (VBlockVCFP vb, ContextP ctx, STRp(gqx));
extern void vcf_seg_INFO_IDREP (VBlockVCFP vb, ContextP ctx, STRp(idrep));
extern int vcf_isaac_info_channel_i (VBlockP vb);

// manta stuff
extern void vcf_manta_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_manta_ID (VBlockVCFP vb, STRp(id));

// Ultima Genomics stuff
extern void vcf_ultima_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_INFO_X_LM_RM (VBlockVCFP vb, ContextP ctx, STRp(seq));
extern void vcf_seg_INFO_X_IL (VBlockVCFP vb, ContextP ctx, STRp(il_str));
extern void vcf_seg_INFO_X_IC (VBlockVCFP vb, ContextP ctx, STRp(ic_str));
extern void vcf_seg_INFO_X_HIN (VBlockVCFP vb, ContextP ctx, STRp(hin_str));
extern void vcf_seg_INFO_X_HIL (VBlockVCFP vb, ContextP ctx, STRp(hil_str));
extern void vcf_seg_INFO_FILTERED_HAPS (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_seg_INFO_VARIANT_TYPE (VBlockVCFP vb, ContextP ctx, STRp(vt));

// Platypus stuff
extern void vcf_platypus_zip_initialize (void);
extern void vcf_platypus_seg_initialize (VBlockVCFP vb);
extern void vcf_seg_playpus_INFO_SC (VBlockVCFP vb, ContextP ctx, STRp(seq));
extern void vcf_seg_playpus_INFO_TCR (VBlockVCFP vb, ContextP ctx, STRp(tcr_str));
extern void vcf_seg_playpus_INFO_WS_WE (VBlockVCFP vb, ContextP ctx, STRp(value));
extern void vcf_seg_playpus_INFO_HP (VBlockVCFP vb, ContextP ctx, STRp(hp_str));    
extern void vcf_seg_platypus_FORMAT_GOF (VBlockVCFP vb, ContextP ctx, STRp(gof_str));

// Liftover Piz
extern void vcf_lo_piz_TOPLEVEL_cb_filter_line (VBlockVCFP vb);

#define VCF_ERR_PREFIX { progress_newline(); fprintf (stderr, "Error %s:%u in variant %.*s:%"PRId64": ", __FUNCLINE, STRf(vb->chrom_name), vb->last_int (VCF_POS)); }
#define ASSVCF(condition, format, ...) ({ if (!(condition)) { VCF_ERR_PREFIX; fprintf (stderr, (format), __VA_ARGS__); fprintf (stderr, "\n"); exit_on_error(true); }})
#define ASSVCF0(condition, msg)        ASSVCF ((condition), msg "%s", "")
#define WARNVCF(format, ...)           ({ if (!flag.quiet)  { VCF_ERR_PREFIX; fprintf (stderr, format "\n", __VA_ARGS__); } })

// inserting INFO fields after all Samples have been reconstructed
extern void vcf_piz_insert_field (VBlockVCFP vb, ContextP ctx, STRp(value), int chars_reserved);

#define vcf_piz_defer_to_after_samples(x) ({    \
    ctx->special_res = SPEC_RES_DEFERRED;       \
    if (reconstruct) {                          \
        ctx->recon_insertion = vb->line_i + 1;  \
        Ltxt += segconf.wid_##x.width; /* our best guess - minimize memory moves during vcf_piz_insert_field */ \
    }                                           \
})

#define IS_RECON_INSERTION(ctx) ((ctx)->recon_insertion == vb->line_i + 1)