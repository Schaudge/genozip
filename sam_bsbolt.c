// ------------------------------------------------------------------
//   sam_bsbolt.c
//   Copyright (C) 2022-2022 Genozip Limited
//   Please see terms and conditions in the file LICENSE.txt

// Compresses auxilliary fields generated by BSBolt

#include "genozip.h"
#include "sam_private.h"
#include "strings.h"
#include "reference.h"
#include "segconf.h"
#include "seg.h"
#include "piz.h"
#include "reconstruct.h"

// Mapping strand (C=Crick, W=Watson) and alignment conversion pattern (C2T or G2A)
// 4 possible values: W_C2T ; W_G2A ; C_C2T ; C_G2A
void sam_seg_bsbolt_YS_Z (VBlockSAMP vb, ZipDataLineSAM *dl, STRp(ys), unsigned add_bytes)
{
    // note: BSBolt always maps Watson strand alignments to the '+' strand and Crick to the '-' strand
    if (ys_len == 5 && ys[0] == "WC"[dl->FLAG.rev_comp] && (!memcmp (ys+1, "_C2T", 4) || !memcmp (ys+1, "_G2A", 4)))
        seg_by_did (VB, (char[]){ SNIP_SPECIAL, SAM_SPECIAL_BSBOLT_YS, ys[2] }, 3, OPTION_YS_Z, add_bytes);

    else 
        seg_by_did (VB, STRa(ys), OPTION_YS_Z, add_bytes);
}

SPECIAL_RECONSTRUCTOR (sam_piz_special_BSBOLT_YS)
{
    if (reconstruct) {
        RECONSTRUCT1 ("WC"[last_flags.rev_comp]);
        RECONSTRUCT (snip[0]=='C' ? "_C2T" : "_G2A", 4);
    }

    return NO_NEW_VALUE;
}

// Read bisulfite conversion position and context
// Example: XB:Z:2z10x4z10z5zzZz10z1z5zZzz3z9z1zzz1zzz1z3z8zz15z1X2z5
// X=methylated CG x=un-methylated CG Y=methylated CHG y=un-methylated CHG Z=methylated CHH z=un-methylated CHH ; numbers=gaps
void sam_seg_bsbolt_XB (VBlockSAMP vb, ZipDataLineSAM *dl, STRp(XB), unsigned add_bytes)
{
    if (segconf.running || flag.reference == REF_INTERNAL || vb->cigar_missing || vb->seq_missing) 
        goto fallback; // note: an external reference is required for this method
/*
    int32_t inc_soft_clip = true; //(vb->XG_inc_S == XG_WITH_S) ? vb->soft_clip[0] : 0; // soft clip length, if we need to include it
        
    // uint32_t expected_xm_len = vb->ref_consumed + dl->SEQ.len - vb->ref_and_seq_consumed;
    // if (vb->XG_inc_S == XG_WITHOUT_S) expected_xm_len -= vb->soft_clip[0] + vb->soft_clip[1];

    // if (expected_xm_len != XM_len)  { // XM includes entries for I,D,M, maybe left-S
    //     if (flag.show_wrong_xm)
    //         iprintf ("%s: XM not special bc bad length (no harm): cigar=\"%s\". Expecting: ref_consumed + seq_len - ref_and_seq_consumed=%d == XM_len=%d\n",
    //                  LN_NAME, vb->last_cigar, vb->ref_consumed + dl->SEQ.len - vb->ref_and_seq_consumed, XM_len);
    //     goto fallback;
    // }

    // // note: we don't require XG to be verified, but we require it to be the expected length
    // if (vb->ref_consumed + inc_soft_clip != vb->XG.len - 4) {
    //     if (flag.show_wrong_xm)
    //         iprintf ("%s: XM not special bc bad length (no harm): cigar=\"%s\". Expecting: (vb->ref_consumed%s)=%d != (vb->XG.len-4)=%d\n",
    //                  LN_NAME, vb->last_cigar, (vb->XG_inc_S==XG_WITH_S ? " + vb->soft_clip[0]":""), vb->ref_consumed + inc_soft_clip, (int)vb->XG.len - 4);
    //     goto fallback;
    // }

    Range *range = vb->cigar_missing ? NULL 
                                     : ref_seg_get_locked_range (VB, gref, vb->chrom_node_index, STRa(vb->chrom_name), pos, ref_consumed, WORD_INDEX_NONE, seq, 
                                                                 flag.reference == REF_EXTERNAL ? NULL : &lock);

    rom seq = IS_BAM_ZIP ? B1STc (vb->textual_seq) : Btxt (dl->SEQ.index);
    bool rev_comp = dl->FLAG.rev_comp;

    ARRAY (BamCigarOp, cigar, vb->binary_cigar);
    int op_i = (vb->XG_inc_S == XG_WITHOUT_S && cigar[0].op == BC_S);
    BamCigarOp op = {};

    for (int32_t i=0; i < XM_len; i++, op.n--) {

        XM_UPDATE_OP;

        char predicted_xm = rev_comp ? XM_predict_rev (op.op, xg[0], xg[-1], xg[-2], *seq)
                                     : XM_predict_fwd (op.op, xg[0], xg[+1], xg[+2], *seq);

        uint32_t xm_i = rev_comp ? XM_len-i-1 : i;
        char this_xm = XM[xm_i];

        if (predicted_xm != this_xm) {
            if (flag.show_wrong_xm)
                iprintf ("%s: XM mis-predicted (no harm): xm_i=%u revcomp=%s: cigar=%s op=%c xg=%c seq=%c predicted_xm=%c xm=%c\n",
                         LN_NAME, xm_i, TF(rev_comp), vb->last_cigar, cigar_op_to_char[op.op], *xg, *seq, predicted_xm, this_xm);
            goto fallback;
        }

// printf ("op=%c\n", cigar_op_to_char[op.op]);
        if (op.op != BC_I) xg++;
        if (op.op != BC_D) seq++;
    }

    // we include the argument XG_inc_S because we might have this special even if XG failed verification and has no special
    seg_by_did (VB, (char[]){ SNIP_SPECIAL, SAM_SPECIAL_BSSEEKER2_XM, '0' + vb->XG_inc_S }, 3, OPTION_XM_Z, add_bytes);
    return;

*/
fallback:
    seg_add_to_local_text (VB, CTX(OPTION_XB_Z), STRa(XB), true, add_bytes);
}

/*    VBlockSAMP vb = (VBlockSAMP)vb_;
SPECIAL_RECONSTRUCTOR_DT (sam_piz_special_BSBOLT_XB)
{
    if (!reconstruct) goto done;

    XgIncSType XG_inc_S = snip[0] - '0';

    STR(xg);
    reconstruct_peek (VB, CTX (OPTION_XG_Z), pSTRa(xg));

    bool rev_comp = last_flags.rev_comp;

    // case: reconstructed to txt_data: copy data peeked 1. because our recon will overwrite it 2. so we don't need to reconstruct it again
    buf_alloc_exact (vb, vb->XG, xg_len-2, char, "xg"); // remove the two underscores
    memcpy (Bc (vb->XG, 0), xg, 2);
    memcpy (Bc (vb->XG, 2), xg+3, xg_len - 6);
    memcpy (Bc (vb->XG, vb->XG.len-2), xg+xg_len-2, 2);
    xg = B1STc(vb->XG);
    xg_len = vb->XG.len;
    int32_t xg_i=0;

    rom seq = IS_SRC_and_RECON_BAM_PIZ ? vb->textual_seq.data : last_txt(VB, SAM_SQBITMAP);
    char *recon = BAFTtxt;
    ARRAY (BamCigarOp, cigar, vb->binary_cigar);
    int op_i = (XG_inc_S == XG_WITHOUT_S && cigar[0].op == BC_S);
    BamCigarOp op = {};

    uint32_t xm_len = vb->ref_consumed + vb->seq_len - vb->ref_and_seq_consumed;
    if (XG_inc_S == XG_WITHOUT_S) xm_len -= vb->soft_clip[0] + vb->soft_clip[1];

// printf ("xg=%.*s\n", STRf(xg));
// printf ("SEQ= %.*s\n", seq_len, seq);

// printf ("%.*s cigar=", vb->textual_cigar.len, vb->textual_cigar.data);
// for (int i=0; i < cigar_len; i++)
// printf ("%c",cigar_op_to_char[cigar[i].op]);
// printf ("\n");
    for (int32_t i=0; i < xm_len; i++, op.n--) {

        XM_UPDATE_OP

        #define XG_FWD(x) xg[(x)+2] 
        #define XG_REV(x) complem((int)xg[1+(xg_len-4)-(x)])
                
        char xm = rev_comp ? XM_predict_rev (op.op, XG_REV(xg_i), XG_REV(xg_i-1), XG_REV(xg_i-2), *seq)
                           : XM_predict_fwd (op.op, XG_FWD(xg_i), XG_FWD(xg_i+1), XG_FWD(xg_i+2), *seq);
//  printf ("xg0=%c xg1=%c xg2=%c seq=%c xm=%c      ind0=%d ind1=%d ind2=%d  XG[xg0]=%c\n", 
//   XG_REV(i), XG_REV(i+1), XG_REV(i+2), seq[i], xm,
//   XG_REV_IDX(i), XG_REV_IDX(i+1), XG_REV_IDX(i+2), XG_REV(i));

        recon[rev_comp ? xm_len-i-1 : i] = xm;
//printf ("%c", cigar_op_to_char[op.op]);
//printf ("op=%c\n", cigar_op_to_char[op.op]);
        if (op.op != BC_I) xg_i++;
        if (op.op != BC_D) seq++;
    }

    vb->txt_data.len += xm_len;
// printf ("\n");

// printf ("cigar2=");
// for (int i=0; i < cigar_len; i++)
// printf ("%c",cigar_op_to_char[cigar[i].op]);
// printf ("\n");

    done: return NO_NEW_VALUE;
}
*/
  